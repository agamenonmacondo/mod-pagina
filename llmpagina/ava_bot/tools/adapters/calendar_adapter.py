import os
import sys
import json
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, Any

logger = logging.getLogger(__name__)

# ‚úÖ AGREGAR OAUTH_HELPER AL PATH
current_dir = Path(__file__).parent
tools_dir = current_dir.parent
ava_bot_dir = tools_dir.parent
utils_dir = ava_bot_dir / 'utils'

# Agregar ruta de utils
if str(utils_dir) not in sys.path:
    sys.path.insert(0, str(utils_dir))

# ‚úÖ IMPORTAR OAUTH_HELPER
try:
    from oauth_helper import get_google_credentials
    OAUTH_HELPER_AVAILABLE = True
    print("‚úÖ OAuth helper disponible para Calendar")
except ImportError:
    OAUTH_HELPER_AVAILABLE = False
    print("‚ö†Ô∏è OAuth helper no disponible para Calendar")

class CalendarAdapter:
    """Adaptador para crear eventos de Google Calendar con OAuth env vars"""
    
    name = "calendar"
    description = "Create and manage Google Calendar events with OAuth env vars"
    
    def __init__(self):
        """Inicializaci√≥n con OAuth desde variables de entorno"""
        try:
            self.description = "Ava Bot calendar tool - OAuth env vars support"
            
            # ‚úÖ INTENTAR OAUTH HELPER PRIMERO
            self.calendar_manager = None
            self.has_credentials = False
            
            if OAUTH_HELPER_AVAILABLE:
                try:
                    # Test de credenciales OAuth desde env vars
                    creds = get_google_credentials(['https://www.googleapis.com/auth/calendar'])
                    if creds:
                        # ‚úÖ CREAR CALENDAR MANAGER CON OAUTH HELPER
                        self._initialize_calendar_with_oauth(creds)
                        logger.info("‚úÖ CalendarManager inicializado con OAuth env vars")
                        print("‚úÖ CalendarManager cargado - OAuth desde variables de entorno")
                    else:
                        logger.warning("‚ö†Ô∏è OAuth env vars no disponibles")
                except Exception as e:
                    logger.error(f"‚ùå Error con OAuth env vars: {e}")
            
            # ‚úÖ FALLBACK: M√©todo legacy con archivos
            if not self.has_credentials:
                logger.info("üîÑ Intentando m√©todo legacy con archivos...")
                self._initialize_calendar_legacy()
            
            logger.info("‚úÖ CalendarAdapter inicializado")
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando CalendarAdapter: {e}")
            self.has_credentials = False
            self.calendar_manager = None
            self.description = "Ava Bot calendar tool - Basic mode"
    
    def _initialize_calendar_with_oauth(self, creds):
        """Inicializar CalendarManager con credenciales OAuth"""
        try:
            from googleapiclient.discovery import build
            
            class OAuthCalendarManager:
                """CalendarManager usando OAuth desde env vars"""
                
                def __init__(self, credentials):
                    self.service = build('calendar', 'v3', credentials=credentials)
                
                def create_event(self, summary, start_time, end_time, attendees=None, description="", timezone='America/Bogota'):
                    """Crear evento en Google Calendar"""
                    
                    # Procesar asistentes
                    event_attendees = []
                    if attendees:
                        if isinstance(attendees, str):
                            for email in attendees.split(','):
                                email = email.strip()
                                if email and '@' in email:
                                    event_attendees.append({'email': email})
                        elif isinstance(attendees, list):
                            for email in attendees:
                                if email and '@' in email:
                                    event_attendees.append({'email': email.strip()})
                    
                    # Crear evento
                    event = {
                        'summary': summary,
                        'description': description,
                        'start': {
                            'dateTime': start_time,
                            'timeZone': timezone,
                        },
                        'end': {
                            'dateTime': end_time,
                            'timeZone': timezone,
                        },
                        'attendees': event_attendees,
                        'reminders': {
                            'useDefault': False,
                            'overrides': [
                                {'method': 'email', 'minutes': 24 * 60},
                                {'method': 'popup', 'minutes': 10},
                            ],
                        },
                    }
                    
                    created_event = self.service.events().insert(calendarId='primary', body=event).execute()
                    
                    return {
                        'id': created_event.get('id'),
                        'htmlLink': created_event.get('htmlLink'),
                        'summary': created_event.get('summary'),
                        'start': created_event.get('start', {}).get('dateTime'),
                        'end': created_event.get('end', {}).get('dateTime'),
                        'attendees': [att.get('email') for att in created_event.get('attendees', [])],
                        'error': None
                    }
                
                def list_events(self, max_results=10):
                    """Listar eventos del calendario"""
                    now = datetime.utcnow().isoformat() + 'Z'
                    
                    events_result = self.service.events().list(
                        calendarId='primary',
                        timeMin=now,
                        maxResults=max_results,
                        singleEvents=True,
                        orderBy='startTime'
                    ).execute()
                    
                    events = events_result.get('items', [])
                    
                    processed_events = []
                    for event in events:
                        processed_events.append({
                            'summary': event.get('summary', 'Sin t√≠tulo'),
                            'start': event.get('start', {}).get('dateTime', event.get('start', {}).get('date', '')),
                            'end': event.get('end', {}).get('dateTime', event.get('end', {}).get('date', '')),
                            'htmlLink': event.get('htmlLink', ''),
                            'attendees': [att.get('email') for att in event.get('attendees', [])]
                        })
                    
                    return {
                        'count': len(processed_events),
                        'events': processed_events
                    }
            
            self.calendar_manager = OAuthCalendarManager(creds)
            self.has_credentials = True
            
        except Exception as e:
            logger.error(f"Error inicializando OAuthCalendarManager: {e}")
            raise
    
    def _initialize_calendar_legacy(self):
        """M√©todo legacy con archivos JSON"""
        token_path = ava_bot_dir / 'token.json'
        
        if token_path.exists():
            try:
                calendar_nodes_path = str(ava_bot_dir / 'nodes' / 'calendar')
                if calendar_nodes_path not in sys.path:
                    sys.path.append(calendar_nodes_path)
                
                from calendar_manager import CalendarManager
                self.calendar_manager = CalendarManager(str(token_path))
                self.has_credentials = True
                logger.info("‚úÖ CalendarManager legacy inicializado")
                
            except Exception as e:
                logger.error(f"‚ùå Error con m√©todo legacy: {e}")
                self.has_credentials = False
        else:
            logger.info("‚ÑπÔ∏è Token no encontrado - modo b√°sico")
            self.has_credentials = False

    @property
    def schema(self) -> Dict[str, Any]:
        """Schema EXACTO para Calendar - SOLO par√°metros que funcionan"""
        return {
            "type": "object",
            "properties": {
                "action": {
                    "type": "string",
                    "enum": ["create", "list", "check"],
                    "description": "Acci√≥n a realizar"
                },
                "title": {
                    "type": "string",
                    "description": "T√≠tulo del evento (REQUERIDO para create)",
                    "minLength": 1,
                    "maxLength": 200
                },
                "summary": {
                    "type": "string",
                    "description": "T√≠tulo del evento (alternativo a title)"
                },
                "date": {
                    "type": "string",
                    "description": "Fecha y hora de inicio - formato: YYYY-MM-DDTHH:MM:SS"
                },
                "start_time": {
                    "type": "string",
                    "description": "Hora de inicio - formato: YYYY-MM-DDTHH:MM:SS"
                },
                "duration": {
                    "type": "integer",
                    "description": "Duraci√≥n del evento en minutos",
                    "default": 60,
                    "minimum": 15,
                    "maximum": 480
                },
                "attendees": {
                    "type": "string",
                    "description": "Emails de asistentes separados por comas"
                },
                "description": {
                    "type": "string",
                    "description": "Descripci√≥n del evento"
                }
            },
            "required": [],
            "additionalProperties": False
        }
    
    def execute(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Ejecutar acci√≥n de calendario"""
        try:
            # ‚úÖ SELF-TEST AL EJECUTAR
            if not hasattr(self, '_self_tested'):
                self._run_self_test()
                self._self_tested = True
            
            action = arguments.get('action', 'create')
            
            if action == 'create':
                return self._create_event(arguments)
            elif action == 'list':
                return self._list_events(arguments)
            elif action == 'check':
                return self._check_availability(arguments)
            else:
                return {
                    "content": [{
                        "type": "text",
                        "text": f"‚ùå Acci√≥n no reconocida: {action}. Usa: create, list, check"
                    }]
                }
                
        except Exception as e:
            logger.error(f"Error en CalendarAdapter.execute: {e}")
            return {
                "content": [{
                    "type": "text",
                    "text": f"‚ùå Error procesando calendario: {str(e)}"
                }]
            }
    
    def _run_self_test(self):
        """Auto-test actualizado con info de OAuth"""
        print(f"\nüß™ CALENDAR ADAPTER SELF-TEST")
        print(f"=" * 40)
        print(f"üåê OAuth helper: {'‚úÖ Disponible' if OAUTH_HELPER_AVAILABLE else '‚ùå No disponible'}")
        print(f"üîë Has credentials: {self.has_credentials}")
        print(f"üîß Calendar manager: {'‚úÖ Activo' if self.calendar_manager else '‚ùå No disponible'}")
        
        if self.calendar_manager and OAUTH_HELPER_AVAILABLE:
            print(f"üéØ M√©todo: OAuth desde variables de entorno")
        elif self.calendar_manager:
            print(f"üéØ M√©todo: Legacy con archivos JSON")
        else:
            print(f"‚ÑπÔ∏è Modo b√°sico - sin conexi√≥n real")
        
        print(f"=" * 40)
    
    def _create_event(self, arguments: dict) -> dict:
        """Crear evento de calendario con LINKS REALES de Google Calendar"""
        try:
            # ‚úÖ EXTRAER ARGUMENTOS - m√∫ltiples formatos
            event_title = (arguments.get('title') or 
                          arguments.get('summary') or 
                          arguments.get('event_name') or 
                          'Reuni√≥n con AVA')
            
            event_date = (arguments.get('date') or 
                         arguments.get('start_time') or 
                         arguments.get('start'))
            
            event_duration = arguments.get('duration', 60)  # minutos
            event_attendees = arguments.get('attendees', '')
            event_description = arguments.get('description', '')
            
            # ‚úÖ GENERAR FECHA SI NO EXISTE
            if not event_date:
                # Usar ma√±ana a las 3 PM como default
                tomorrow = datetime.now() + timedelta(days=1)
                event_date = tomorrow.replace(hour=15, minute=0, second=0, microsecond=0).isoformat()
                print(f"üìÖ Fecha generada autom√°ticamente: {event_date}")
            
            # ‚úÖ PROCESAR DURACI√ìN
            if isinstance(event_duration, str):
                if 'hour' in event_duration:
                    # "2 hours" -> 120
                    event_duration = int(''.join(filter(str.isdigit, event_duration))) * 60
                elif 'minuto' in event_duration:
                    # "30 minutos" -> 30
                    event_duration = int(''.join(filter(str.isdigit, event_duration)))
                else:
                    event_duration = 60
            
            # ‚úÖ VALIDAR QUE LA FECHA SEA FUTURA
            try:
                if 'T' not in event_date:
                    # Solo fecha, agregar hora
                    event_date = f"{event_date}T15:00:00"
                
                start_time = datetime.fromisoformat(event_date.replace('Z', '+00:00'))
                now = datetime.now()
                
                # Verificar que la fecha sea futura
                if start_time < now:
                    print(f"‚ö†Ô∏è FECHA PASADA DETECTADA: {start_time} < {now}")
                    # Corregir autom√°ticamente
                    start_time = now + timedelta(days=1)
                    start_time = start_time.replace(hour=15, minute=0, second=0, microsecond=0)
                    print(f"‚úÖ FECHA CORREGIDA A: {start_time}")
                
                end_time = start_time + timedelta(minutes=event_duration)
                
                # Convertir a formato ISO string
                start_time_str = start_time.isoformat()
                end_time_str = end_time.isoformat()
                
            except Exception as e:
                print(f"‚ùå Error procesando fecha: {e}")
                # Usar fecha por defecto
                tomorrow = datetime.now() + timedelta(days=1)
                start_time = tomorrow.replace(hour=15, minute=0, second=0, microsecond=0)
                end_time = start_time + timedelta(minutes=event_duration)
                start_time_str = start_time.isoformat()
                end_time_str = end_time.isoformat()
            
            # ‚úÖ CREAR EVENTO REAL CON LINKS REALES
            if self.has_credentials and self.calendar_manager:
                # MODO REAL - CREAR EVENTO EN GOOGLE CALENDAR
                logger.info(f"üóìÔ∏è Creando evento REAL: {event_title}")
                
                try:
                    result = self.calendar_manager.create_event(
                        summary=event_title,
                        start_time=start_time_str,
                        end_time=end_time_str,
                        attendees=event_attendees,
                        description=event_description,
                        timezone='America/Bogota'
                    )
                    
                    if result and not result.get('error'):
                        # ‚úÖ USAR LINKS REALES DEVUELTOS POR GOOGLE
                        event_link = result.get('htmlLink', 'No disponible')
                        event_id = result.get('id', 'No disponible')
                        
                        # ‚úÖ DEBUG - MOSTRAR RESULTADO COMPLETO
                        print(f"\nüîç DEBUG - RESULTADO COMPLETO DE GOOGLE:")
                        print(f"   üìã Claves disponibles: {list(result.keys())}")
                        print(f"   üÜî ID: {event_id}")
                        print(f"   üîó htmlLink: {event_link}")
                        print(f"   üìÖ Summary: {result.get('summary', 'N/A')}")
                        
                        # ‚úÖ FORMATEAR FECHAS PARA MOSTRAR
                        start_formatted = start_time.strftime('%Y-%m-%d %H:%M:%S')
                        end_formatted = end_time.strftime('%Y-%m-%d %H:%M:%S')
                        
                        response_text = f"""üìÖ **¬°EVENTO CREADO EXITOSAMENTE EN GOOGLE CALENDAR!**

üéØ **T√≠tulo:** {event_title}
üìÖ **Inicio:** {start_formatted}
üèÅ **Fin:** {end_formatted}
‚è±Ô∏è **Duraci√≥n:** {event_duration} minutos
üë• **Asistentes:** {event_attendees if event_attendees else 'Ninguno'}

üîó **ENLACE DIRECTO (REAL):** {event_link}
üÜî **ID del evento:** {event_id}

‚úÖ **Estado:** Evento agregado a tu Google Calendar
üìß **Invitaciones:** {('Enviadas a ' + event_attendees) if event_attendees else 'No hay asistentes'}
üîî **Recordatorios:** Configurados autom√°ticamente

üí° **Para acceder:** Haz clic en el enlace o busca por ID en tu calendario"""
                        
                        print(f"‚úÖ EVENTO REAL CREADO CON √âXITO")
                        print(f"üîó Link real: {event_link}")
                        
                    else:
                        # Error en la creaci√≥n
                        error_msg = result.get('error', 'Error desconocido') if result else 'No se recibi√≥ respuesta'
                        response_text = f"""‚ùå **Error creando evento real**

üîç **Detalles del error:** {error_msg}
üìû **Soluci√≥n:** Verifica las credenciales de Google Calendar API

üí° **Alternativas:**
‚Ä¢ Revisa los permisos del token
‚Ä¢ Verifica la configuraci√≥n de la API
‚Ä¢ Contacta al administrador"""
                        
                        print(f"‚ùå ERROR CREANDO EVENTO: {error_msg}")
                        
                except Exception as e:
                    logger.error(f"Error creando evento real: {e}")
                    response_text = f"""‚ùå **Error de conexi√≥n con Google Calendar**

üîç **Error t√©cnico:** {str(e)}
üìû **Posibles causas:**
‚Ä¢ Token expirado o inv√°lido
‚Ä¢ Problemas de conectividad
‚Ä¢ Permisos insuficientes

üí° **Soluci√≥n:** Regenera las credenciales de Google Calendar"""
                    
                    print(f"‚ùå EXCEPCI√ìN CREANDO EVENTO: {e}")
            else:
                # MODO B√ÅSICO INFORMATIVO
                start_formatted = start_time.strftime('%Y-%m-%d %H:%M:%S')
                end_formatted = end_time.strftime('%Y-%m-%d %H:%M:%S')
                
                response_text = f"""üìÖ **Solicitud de evento recibida**

üéØ **T√≠tulo:** {event_title}
üìÖ **Inicio:** {start_formatted}
üèÅ **Fin:** {end_formatted}
‚è±Ô∏è **Duraci√≥n:** {event_duration} minutos
üë• **Asistentes:** {event_attendees if event_attendees else 'Ninguno'}

üìû **Para crear eventos REALES en Google Calendar:**
‚Ä¢ Configura Google Calendar API
‚Ä¢ Autoriza acceso a tu calendario  
‚Ä¢ Reinicia el sistema MCP

üìß **Mientras tanto:** Puedo ayudarte a coordinar por email"""
            
            return {
                "content": [{
                    "type": "text",
                    "text": response_text
                }]
            }
            
        except Exception as e:
            logger.error(f"Error creando evento: {e}")
            return {
                "content": [{
                    "type": "text",
                    "text": f"‚ùå Error creando evento: {str(e)}"
                }]
            }
    
    def _list_events(self, arguments: dict) -> dict:
        """Listar eventos del calendario con LINKS REALES"""
        try:
            if self.has_credentials and self.calendar_manager:
                events_data = self.calendar_manager.list_events(max_results=10)
                
                if events_data['count'] == 0:
                    response_text = "üìÖ **No tienes eventos programados pr√≥ximamente**"
                else:
                    response_text = f"üìÖ **Eventos encontrados: {events_data['count']}**\n\n"
                    
                    for i, event in enumerate(events_data['events'], 1):
                        # ‚úÖ USAR LINKS REALES DE CADA EVENTO
                        event_link = event.get('htmlLink', 'No disponible')
                        
                        response_text += f"**{i}. {event['summary']}**\n"
                        response_text += f"   üìÖ {event['start']} - {event['end']}\n"
                        
                        if event.get('attendees'):
                            response_text += f"   üë• {', '.join(event['attendees'])}\n"
                        
                        if event_link != 'No disponible':
                            response_text += f"   üîó {event_link}\n"
                        
                        response_text += "\n"
            else:
                response_text = """üìÖ **Listado no disponible**

üîß **Configura Google Calendar API para:**
‚Ä¢ Ver eventos existentes
‚Ä¢ Verificar disponibilidad
‚Ä¢ Gestionar tu calendario

üìû **Necesitas ayuda?** Te puedo guiar en la configuraci√≥n"""
            
            return {
                "content": [{
                    "type": "text",
                    "text": response_text
                }]
            }
            
        except Exception as e:
            logger.error(f"Error listando eventos: {e}")
            return {
                "content": [{
                    "type": "text",
                    "text": f"‚ùå Error listando eventos: {str(e)}"
                }]
            }
    
    def _check_availability(self, arguments: dict) -> dict:
        """Verificar disponibilidad en calendario"""
        try:
            event_date = arguments.get('date', '')
            duration = arguments.get('duration', 60)
            
            if not event_date:
                return {
                    "content": [{
                        "type": "text",
                        "text": "‚ùå **Fecha requerida** - Especifica la fecha y hora para verificar disponibilidad"
                    }]
                }
            
            if self.has_credentials and self.calendar_manager:
                start_time = datetime.fromisoformat(event_date.replace('Z', '+00:00'))
                availability = self.calendar_manager.check_availability(
                    start_time, 
                    duration_hours=duration/60
                )
                
                if availability['available']:
                    response_text = f"""‚úÖ **Horario disponible**

üìÖ **Fecha:** {start_time.strftime('%Y-%m-%d %H:%M:%S')}
‚è±Ô∏è **Duraci√≥n:** {duration} minutos
üéØ **Estado:** Libre para programar evento"""
                else:
                    response_text = f"""‚ùå **Horario ocupado**

üìÖ **Fecha:** {start_time.strftime('%Y-%m-%d %H:%M:%S')}
‚è±Ô∏è **Duraci√≥n:** {duration} minutos

‚ö†Ô∏è **Conflictos encontrados:**"""
                    
                    for conflict in availability['conflicts']:
                        response_text += f"\n‚Ä¢ **{conflict['summary']}**"
                        response_text += f"\n  üìÖ {conflict['start']} - {conflict['end']}"
            else:
                response_text = """üìÖ **Verificaci√≥n no disponible**

üîß **Configura Google Calendar API para:**
‚Ä¢ Verificar disponibilidad en tiempo real
‚Ä¢ Detectar conflictos autom√°ticamente
‚Ä¢ Sugerir horarios alternativos"""
            
            return {
                "content": [{
                    "type": "text",
                    "text": response_text
                }]
            }
            
        except Exception as e:
            logger.error(f"Error verificando disponibilidad: {e}")
            return {
                "content": [{
                    "type": "text",
                    "text": f"‚ùå Error verificando disponibilidad: {str(e)}"
                }]
            }
    
    def process(self, arguments: Dict[str, Any]) -> str:
        """Alias para execute (compatibilidad)"""
        result = self.execute(arguments)
        if isinstance(result, dict) and "content" in result:
            return result["content"][0]["text"]
        return str(result)

# ‚úÖ SELF-TEST AL IMPORTAR
if __name__ == "__main__":
    print("üß™ PROBANDO CALENDAR ADAPTER...")
    adapter = CalendarAdapter()
    
    # Test b√°sico con fecha futura
    tomorrow = datetime.now() + timedelta(days=1)
    test_date = tomorrow.replace(hour=16, minute=0, second=0, microsecond=0).isoformat()
    
    test_args = {
        "action": "create",
        "title": "üß™ Test Calendar Adapter - LINKS REALES",
        "date": test_date,
        "duration": 60,
        "attendees": "agamenonmacondo@gmail.com",
        "description": "Evento de prueba para validar links reales de Google Calendar"
    }
    
    print(f"\nüìã ARGUMENTOS DE PRUEBA:")
    print(f"   üìÖ Fecha: {test_date}")
    print(f"   üë§ Asistente: agamenonmacondo@gmail.com")
    
    result = adapter.execute(test_args)
    print(f"\nüìã RESULTADO:")
    print(result["content"][0]["text"])
    
    print(f"\nüîö Test completado")